一、定义：
   使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间发生耦合。
   此模式将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。
二、相关解释：
   责任链模式实现原理图相关说明：
   Handler：抽象处理者。定义出一个处理请求的接口。如果需要，接口可以定义出一个方法，以设定和返回对下家的引用。这个角色通常由一个抽象类或接口实现。
   ConcreteHandler：具体处理者。具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具
                   体处理者可以访问下家。
   Client：客户端
   handleRequest：抽象处理者的公用接口，要求每个链式节点都实现这个接口，能够处理客户端发过来的请求数据。
   对于每个链式节点，需要满足一下两个条件：
   实现抽象处理者（Handler）所定义的抽象接口，能够识别接收的请求；
   有一个successor，用于把当前不能处理的请求转发传递到下一个节点，如此才能形成一个链。（successor是指下一个ConcreteHandler的引用，相当于链表里面
   的next指针）
   由于通过上述的编程设计，使得请求和处理该请求的对象完全没有依赖关系，因为客户端甚至不知道是谁处理了这个请求，这样的话，使得整个链式结构很灵活，可以随
   时添加新的的节点，当然也支持随意调节节点顺序、删除不必要的节点等等操作。


   优点：
   降低耦合度。
   可简化对象的相互连接。
   增强给对象指派职责的灵活性。
   增加新的请求处理类很方便。

   缺点：
   不能保证请求一定被接收。
   系统性能将受到一定影响，而且在进行代码调试时不太方便（可能会造成循环调用）。

三、适用场景：
   1.有多个对象可以处理请求，而处理程序只有在运行时才能确定。
   2.向一组对象发出请求，而不想显式指定处理请求的特定处理程序。

四、Demo说明：
   参考：http://www.jb51.net/article/81756.htm
